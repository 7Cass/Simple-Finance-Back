/**
 * Transaction builder utilities for creating complex transactions
 * (installments and recurring transactions)
 */

import { PrismaClient, Transaction, PaymentMethod } from '@prisma/client';
import { getInstallmentDate } from './date-helpers';

/**
 * Plan for creating installment series
 */
export interface InstallmentPlan {
  description: string;
  amountCents: number; // Total amount (will be divided by installments)
  totalInstallments: number;
  firstDate: Date;
  categoryId: string;
  creditCardId: string;
  userId: string;
  type?: 'INCOME' | 'EXPENSE';
  status?: 'PENDING' | 'COMPLETED';
}

/**
 * Create a series of installment transactions
 * @param prisma Prisma client instance
 * @param plan Installment plan
 * @returns Array of created transactions (parent + children)
 */
export async function createInstallmentSeries(
  prisma: PrismaClient,
  plan: InstallmentPlan
): Promise<Transaction[]> {
  const {
    description,
    amountCents,
    totalInstallments,
    firstDate,
    categoryId,
    creditCardId,
    userId,
    type = 'EXPENSE',
    status = 'COMPLETED',
  } = plan;

  // Calculate amount per installment (round down to avoid exceeding total)
  const amountPerInstallment = Math.floor(amountCents / totalInstallments);
  const remainder = amountCents - amountPerInstallment * totalInstallments;

  const transactions: Transaction[] = [];

  // Create parent transaction (first installment)
  const firstInstallmentAmount = amountPerInstallment + remainder; // Add remainder to first
  const parent = await prisma.transaction.create({
    data: {
      description: `${description} (${1}/${totalInstallments})`,
      amountCents: firstInstallmentAmount,
      type,
      paymentMethod: 'CREDIT_CARD',
      date: firstDate,
      status,
      isInstallment: true,
      installmentNumber: 1,
      totalInstallments,
      parentId: null, // Parent has no parent
      userId,
      categoryId,
      creditCardId,
    },
  });

  transactions.push(parent);
  console.log(`  ✓ Created installment 1/${totalInstallments}: ${description}`);

  // Create child transactions (remaining installments)
  for (let i = 2; i <= totalInstallments; i++) {
    const installmentDate = getInstallmentDate(firstDate, i);

    const child = await prisma.transaction.create({
      data: {
        description: `${description} (${i}/${totalInstallments})`,
        amountCents: amountPerInstallment,
        type,
        paymentMethod: 'CREDIT_CARD',
        date: installmentDate,
        status,
        isInstallment: true,
        installmentNumber: i,
        totalInstallments,
        parentId: parent.id, // Link to parent
        userId,
        categoryId,
        creditCardId,
      },
    });

    transactions.push(child);
    console.log(`  ✓ Created installment ${i}/${totalInstallments}: ${description}`);
  }

  return transactions;
}

/**
 * Plan for creating recurring transaction marker
 */
export interface RecurringTransactionPlan {
  description: string;
  amountCents: number;
  type: 'INCOME' | 'EXPENSE';
  paymentMethod: PaymentMethod;
  recurrenceRule: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY';
  startDate: Date;
  endDate?: Date;
  categoryId: string;
  userId: string;
  bankAccountId?: string;
  creditCardId?: string;
  status?: 'PENDING' | 'COMPLETED';
}

/**
 * Create a recurring transaction marker
 * NOTE: This only creates the marker, NOT the future transactions
 * Future transactions should be generated by a scheduled job
 * @param prisma Prisma client instance
 * @param plan Recurring transaction plan
 * @returns Created transaction (recurring marker)
 */
export async function createRecurringTransaction(
  prisma: PrismaClient,
  plan: RecurringTransactionPlan
): Promise<Transaction> {
  const {
    description,
    amountCents,
    type,
    paymentMethod,
    recurrenceRule,
    startDate,
    endDate,
    categoryId,
    userId,
    bankAccountId,
    creditCardId,
    status = 'COMPLETED',
  } = plan;

  const transaction = await prisma.transaction.create({
    data: {
      description,
      amountCents,
      type,
      paymentMethod,
      date: startDate,
      status,
      isRecurring: true,
      recurrenceRule,
      recurrenceEndDate: endDate || null,
      userId,
      categoryId,
      bankAccountId,
      creditCardId,
    },
  });

  console.log(`  ✓ Created recurring transaction: ${description} (${recurrenceRule})`);

  return transaction;
}

/**
 * Generate future occurrences of a recurring transaction
 * This simulates what a scheduled job would do
 * @param prisma Prisma client instance
 * @param baseTransaction The recurring transaction template
 * @param count Number of future occurrences to generate
 * @returns Array of generated transactions
 */
export async function generateRecurringOccurrences(
  prisma: PrismaClient,
  baseTransaction: Transaction,
  count: number
): Promise<Transaction[]> {
  if (!baseTransaction.isRecurring || !baseTransaction.recurrenceRule) {
    throw new Error('Transaction must be recurring');
  }

  const transactions: Transaction[] = [];
  let currentDate = new Date(baseTransaction.date);

  for (let i = 0; i < count; i++) {
    // Calculate next occurrence date based on recurrence rule
    switch (baseTransaction.recurrenceRule) {
      case 'DAILY':
        currentDate.setDate(currentDate.getDate() + 1);
        break;
      case 'WEEKLY':
        currentDate.setDate(currentDate.getDate() + 7);
        break;
      case 'MONTHLY':
        currentDate.setMonth(currentDate.getMonth() + 1);
        break;
      case 'YEARLY':
        currentDate.setFullYear(currentDate.getFullYear() + 1);
        break;
    }

    // Check if we've exceeded the recurrence end date
    if (baseTransaction.recurrenceEndDate && currentDate > baseTransaction.recurrenceEndDate) {
      break;
    }

    const transaction = await prisma.transaction.create({
      data: {
        description: baseTransaction.description,
        amountCents: baseTransaction.amountCents,
        type: baseTransaction.type,
        paymentMethod: baseTransaction.paymentMethod,
        date: new Date(currentDate),
        status: 'PENDING', // Future occurrences start as PENDING
        isRecurring: true,
        recurrenceRule: baseTransaction.recurrenceRule,
        recurrenceEndDate: baseTransaction.recurrenceEndDate,
        userId: baseTransaction.userId,
        categoryId: baseTransaction.categoryId || undefined,
        bankAccountId: baseTransaction.bankAccountId || undefined,
        creditCardId: baseTransaction.creditCardId || undefined,
      },
    });

    transactions.push(transaction);
  }

  console.log(`  ✓ Generated ${transactions.length} recurring occurrences`);

  return transactions;
}

/**
 * Calculate total amount of an installment series including remainder
 */
export function calculateInstallmentAmount(
  totalAmount: number,
  totalInstallments: number,
  installmentNumber: number
): number {
  const amountPerInstallment = Math.floor(totalAmount / totalInstallments);
  const remainder = totalAmount - amountPerInstallment * totalInstallments;

  // First installment gets the remainder
  if (installmentNumber === 1) {
    return amountPerInstallment + remainder;
  }

  return amountPerInstallment;
}
